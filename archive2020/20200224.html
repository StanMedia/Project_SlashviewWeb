<!DOCTYPE html><html><head><meta charset=utf-8 /><meta name=viewport content="width=device-width, initial-scale=1" /><link href=/.file/site.css rel=stylesheet /><script src=/.include/jquery/jquery.min.js></script></head><body><header></header><main><h1>LINQ筆記：將兩個IEnumerable List集合物件內容相加</h1><p>今天剛好有個需求，需要將兩個<code>List&lt;string></code>進行疊加後再進行相關處理，由於之前沒有做過這方面的程式碼，因此在網路爬了一些知識，補充在這個地方。</p><p><img src=https://content.slashview.com/img/2020/20200224_01.jpg alt="" /></p><p>假設我們今天有兩個<code>List&lt;string></code>分別為oListA與oListB，其值詳見下列程式碼：</p><pre><code class=language-cs>System.Collections.Generic.List&lt;string> oListA = new List&lt;string>() { "AAA", "BBB", "CCC" };
System.Collections.Generic.List&lt;string> oListB = new List&lt;string>() { "CCC", "DDD", "EEE" };
</code></pre><h2>使用AddRange()方法</h2><p>oListA可以使用AddRange()方法，來將oListB的內容疊加入oListA，這樣的做法的缺點是oListA原本的內容會被異動，在某些情況下這可被視為汙染，要不要用就看你自己的選擇了。語法如下：</p><pre><code class=language-cs>oListA.AddRange(oListB);
</code></pre><p>在這行指令之後，你去foreach oListA會得到6個內容值的<code>List&lt;string></code>，分別為AAA、BBB、CCC、CCC、DDD、EEE。</p><h3>使用Concat()方法</h3><p>oListA可以使用Concat()方法，將oListB的內容相加後拋出一個全新的<code>IEnumerable&lt;string></code>，如果以這篇文章的標題來看，這樣的作法將會獲得最佳的效率且不汙染原本的oListA與oListB（搞不好你的程式碼之後還需要用到這兩個集合）。</p><pre><code class=language-cs>var oListC = oListA.Concat(oListB);
</code></pre><p>在這行指令之後，你去foreach oListC會得到6個內容值的<code>IEnumerable&lt;string></code>，分別為AAA、BBB、CCC、CCC、DDD、EEE。而oListA的內容依然保持為3個內容值。</p><h3>使用Union()方法</h3><p>基本上Union()方法與Concat()方法雷同，但是他會將兩個集合中重複的元素排除，所以如果你在疊加的結果中希望排除重複的元素，那麼這個指令會非常的適合你。</p><pre><code class=language-cs>var oListC = oListA.Union(oListB);
</code></pre><p>在這行指令之後，你去foreach oListC會得到5個內容值的IEnumerable，分別為AAA、BBB、CCC、DDD、EEE。</p><h3>補充說明：針對IEnumerable的null檢查</h3><p>上面的LINQ方法看起來操作非常簡單，但裡面卻藏著一個小坑，那就是你必須確保oListA、oListB等集合物件不可為null，這時候會有人建議你採用<code>DefaultIfEmpty&lt;T></code>，可是這個DefaultIfEmpty必須指定一個非null的預設值，有時候反而會汙染我們要的集合物件。例如：</p><pre><code class=language-cs>System.Collections.Generic.List&lt;string> oFiles = new List&lt;string>() { 
  "DoNotDeleteAAA.txt",
  "DoNotDeleteBBB.txt",
  "DoNotDeleteCCC.txt",
};
//篩選出想要刪除的檔案以利刪除
var oWannaDelete = oFiles.Where(x => !x.StartsWith("DoNot")).Select(x => x).DefaultIfEmpty("NoFiles!");.
</code></pre><p>從上面的程式碼可以看到，如果我們想要利用DefaultIfEmpty方法來避免null的話，那麼只會落入更尷尬的處境，例如我們認為oWannaDeleter就是我要刪除的檔案列表，當我們真的去執行刪除動作但當下並沒有適合刪除的檔案時，大不了就不執行離開了。但以這個例子來說，程式碼可能會想要去針對一個不存在的「NoFiles!」檔案進行刪除。</p><p>在這種狀況使用DefaultIfEmpty()方法，簡直是拿石頭砸自己的腳。</p><p>比較恰當的使用方式是採用??運算子（null運算子）以及<code>System.Linq.Enumerable.Empty&lt;T></code>來進行空集合的指派，詳見下列範例程式碼（以上述Concat()方法為例子，進行null檢查修補）：</p><pre><code class=language-cs>var oListC = (oListA ?? System.Linq.Enumerable.Empty()).Concat(oListB ?? System.Linq.Enumerable.Empty());
</code></pre><p>這樣的寫法在最倒楣的情況下，oListA、oListB經過Linq運算均Select出null，仍然可以安全的保證疊加出一個oListC空集合。</p><h6>C# LINQ List(int) List(string) Add Combine Lists System.Collections.Generic Null Check</h6></main><footer></footer><script src=/.file/site.js></script></body></html>
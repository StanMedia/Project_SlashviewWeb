<!DOCTYPE html><html><head><meta charset=utf-8 /><meta name=viewport content="width=device-width, initial-scale=1" /><link href=/.file/site.css rel=stylesheet /><script src=/.include/jquery/jquery.min.js></script></head><body><header></header><main><h1>Java初探：利用跨package之類別編譯，來展示成員存取限制（權限）</h1><p>Java的成員存取限制（權限）分成三種：一、用類別名稱來存取類別資料或方法成員。二、用物件存取實體資料或方法成員。三、於子類別中存取父類別之資料或方法成員。</p><p>以下先建立起跨package的實驗環境，也就是我們將建立起package Things以及package Human這兩個類別，並試著讓它們待在自己應存之分類環境，然後我們可以成功將其編譯與執行。透過這個例子我們將逐一介紹private、package（default）、public等存取限制修飾子之功用。</p><h2>建立類別與執行編譯</h2><p>Step 1. 在C:\javaTest資料夾下，建立Things與Human資料夾。</p><p><img src=https://content.slashview.com/img/2013/20130705_01.jpg alt="" /></p><p>Step 2. 在C:\javaTest\Things下，建立Thing.java類別程式。</p><p><img src=https://content.slashview.com/img/2013/20130705_02.jpg alt="" /></p><p>Step 3. 在C:\javaTest\Human下，建立People.java類別程式。</p><p><img src=https://content.slashview.com/img/2013/20130705_03.jpg alt="" /></p><p>Step 4. 將目錄切換到Human資料夾下，對People.java進行編譯，這時候java compiler會自動啟動make編譯機制，幫你把Thing.java也一起處理掉了。</p><p><img src=https://content.slashview.com/img/2013/20130705_04.jpg alt="" /></p><pre><code class=language-txt>//編譯People.java
C:\javaTest\Human>javac -cp C:\javaTest People.java
//執行People.java
C:\javaTest\Human>java -cp C:\javaTest Human.People
</code></pre><p>Step 5. 由執行結果我們可以觀察到，Pepole類別繼承自Thing類別，算是他的小孩子，而Thing有一個公開（public）的資料成員叫_iAge，這裡我們把他定義是年齡。當我們進行People建構子的呼叫時，我們先把原先繼承的_iAge印出來看，結果是0沒錯。而當我們建構完成後再印出來看，就是1了。再main方法中用物件的角度來呼叫實體資料成員，印出來的答案依然是1。</p><h2>private存取限制修飾子</h2><p>private通常用於資訊隱藏之用途，在物件中，不必要讓人家看的，就不需要外顯出來，這樣的觀念叫作「封裝」（Encapsulation）。private是最嚴格的存取限制修飾子，加了這個字眼後只有類別本體內部的程式碼可以完成「Java的成員存取三種限制」之要求，其它的類別想要用，想都別想。以下是證明：</p><p><img src=https://content.slashview.com/img/2013/20130705_05.jpg alt="" /></p><h2>package（default）存取限制修飾子</h2><p>其實沒有什麼所謂的package存取限制修飾子，如果你什麼都沒有寫，那就是使用預設值，也就是所謂的package模式。宣告成這種存取限制，表示在同一個package內所有的類別，都可以完成「Java的成員存取三種限制」之要求，一旦跳脫了同一個package範圍之外，就不能夠使用了。</p><p><img src=https://content.slashview.com/img/2013/20130705_06.jpg alt="" /></p><h2>protected存取限制修飾子</h2><p>protected存取限制修飾子的作用，就是用於跨package繼承時，仍然可以完成「Java的成員存取三種限制」之要求，那可能會有人覺得，為何還要這樣分？一開始程式碼中的public不就可以跨package來完成「Java的成員存取三種限制」之要求了嗎？基本上，這樣的想法是沒錯的，但是還是有其差別！</p><p><img src=https://content.slashview.com/img/2013/20130705_07.jpg alt="" /></p><p>protected跟public都支援跨package存取，但差別是protected於子類別繼承後，只能在類別資料成員或類別方法成員中存取，一旦你對其實體化（實例化）後，它會鎖定拒絕你去存取它。這種感覺就像是，B類別繼承至A類別，則B類別中的成員可以直接存取A類別之資源，無論A,B是否在同一個Package下。但是，當有一個實作程式，直接調用A類別要實際運用，去變更他的實體成員時，這時候A類別如果成員有被下protected存取限制修飾子，它會悍然的拒絕你的存取。</p><p><img src=https://content.slashview.com/img/2013/20130705_08.jpg alt="" /></p><h2>public存取限制修飾子</h2><p>最後就是我們文章一開始的範例就採用的public存取限制修飾子啦！在public的世界裡面，一切沒有限制，歡迎使用！例如下圖所示，本來被protected封印的資料成員，突然間就變成可以通過編譯了！</p><p><img src=https://content.slashview.com/img/2013/20130705_09.jpg alt="" /></p><h6>Java SCJP Package Compiler ClassPath Private Default Protected Public Access</h6></main><footer></footer><script src=/.file/site.js></script><script src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-7039045520564660"></script></body></html>
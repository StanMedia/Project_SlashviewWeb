<!DOCTYPE html><html><head><meta charset=utf-8 /><meta name=viewport content="width=device-width, initial-scale=1" /><link href=/.file/site.css rel=stylesheet /><script src=/.include/jquery/jquery.min.js></script></head><body><header></header><main><h1>物件導向的心得筆記</h1><p>將一些在寫物件導向使用到的關鍵字寫下來，以後好當工具文件翻閱。</p><p><img src=https://content.slashview.com/img/2013/20130909_01.jpg alt="" /></p><h2>存取修飾子</h2><table class="table table-hover"><thead><tr><th>關鍵字</th><th>說明</th></tr></thead><tbody><tr><td>private</td><td>宣告成private的成員，只能夠在自己類別的程式中存取。</td></tr><tr><td>protected</td><td>宣告為protected的成員，只開放給自己類別與子類別的程式中使用。</td></tr><tr><td>internal</td><td>宣告為internal的成員，只開放給自己類別以及專案中其他的類別的程式使用。</td></tr><tr><td>protected internal</td><td>開放給自己類別與子類別的程式，還有專案中其他類別中的程式都可以存取。</td></tr><tr><td>public</td><td>宣告public的成員，沒有任何的存取限制。</td></tr></tbody></table><h2>修飾子</h2><table class="table table-hover"><thead><tr><th>關鍵字</th><th>說明</th></tr></thead><tbody><tr><td>readonly</td><td>宣告唯讀欄位（不可用於方法），並且在建構子執行中寫入，在實體完成後就不可以再存值。</td></tr><tr><td>static</td><td>宣告靜態的類別、欄位、屬性或方法。靜態的屬性或是方法的程式中，只能夠直接存取類別中其它的靜態成員，不可以直接存取類別中的實體成員。Int32.Parse是靜態（static）方法。</td></tr><tr><td>virtual</td><td>與override匹配，用來進行屬性或方法的覆寫，另外，在覆寫時是不可以變更其「存取性」的。</td></tr><tr><td>new</td><td><p>多型（polymorphism）之實作，可以隱藏從父類別繼承過來的public欄位、屬性、方法。</p><p>用來解決父類別中的方法沒有被設定virtual時的作法。以方法testA為例：</p><p>父: private testA，子: private testA；就算透過別的方法繞路，也可以呼叫到子testA。</p><p>父:private testA，子:public testA；不用使用new修飾子，呼叫到子testA。</p><p>父:public testA，子:private new testA；new省略會被警告，呼叫到父testA。</p><p>父:public testA，子:public new testA；new省略會被警告，呼叫到子testA。</p></td></tr></tbody></table><h2>屬性</h2><table class="table table-hover"><thead><tr><th>關鍵字</th><th>說明</th></tr></thead><tbody><tr><td>get</td><td>只有宣告get存取子，而沒有宣告set存取子，該屬性就變成「唯讀」。</td></tr><tr><td>set</td><td>只有宣告set存取子，而沒有宣告get存取子，則該屬性就是「唯寫」。</td></tr><tr><td>value</td><td>存入維護物件狀態的資料欄位中，外部程式輸入的資料會自動存入名為value的變數。</td></tr></tbody></table><h2>建構子初始式（constructor initializers）</h2><table class="table table-hover"><thead><tr><th>關鍵字</th><th>說明</th></tr></thead><tbody><tr><td>this（本體類別版）</td><td><p>class Test …</p><p>public Test(int A, int B) …</p><p>public Test(int A):this(int A, 100)</p></td></tr><tr><td>base（繼承版)</td><td><p>建構子初始式會讓相同類別或基礎類別中的其它建構子，在該建構子的主體程式之前執行。</p><p>class ExtDate:Date …</p><p>public ExtDate(int iYear, int iMonth, int iDay):base(iYear, iMonth, iDay)</p><p>上面的base會自動將使用者本來要引入的iYear, iMonth, iDay先帶入到後面呼叫基底Date類別的三引數建構子，接下來再運行ExtDate建構子。建構子初始式會在程式設計師沒有提供時，自動補入一個無參數建構子。</p></td></tr></tbody></table><h2>物件轉型</h2><table class="table table-hover"><thead><tr><th>關鍵字</th><th>說明</th></tr></thead><tbody><tr><td>隱式轉換 implicit</td><td>子類別所生出來的實體，可以直接指派給父類別實體，這時C#會自動隱式轉換，執行所謂的upcasting。反過來，如果父類別實體要指派給子類别，就要明確的轉型downcasting。</td></tr><tr><td>顯式轉換 explicit</td><td>DateTime AAA = (DateTime)BBB; 如果錯誤的話，會丟出Exception。</td></tr><tr><td>typeof</td><td>C#運算子，可以取出一個實體的類别型別（Type物件）。typeof(AAA);</td></tr><tr><td>.GetType()</td><td><p>System.Object中的一個實體方法，可以取出一個實體的類别型別（Type物件）。AAA.GetType();</p><p>typeof或.GetType()是直接比對Heap區，也就是並沒有物件的繼承比對。</p><p>typeof或.GetType()這兩種方式，在物件是null時會發生Exception。</p></td></tr><tr><td>as</td><td>DateTime AAA = BBB as DateTime; 如果錯誤的話，AAA會被指派一個null，可檢查null來求證。</td></tr><tr><td>is</td><td>判斷物件是否等於某一類別。優點：null時不會出錯；缺點：實體等於父類別時也會傳回True。</td></tr><tr><td>boxing、unboxing</td><td><p>一個實值型別指派給一個object（System.Object），這時會觸發boxing，反之就叫作unboxing。</p><p>在程式撰寫時期應該盡量避免，因為boxing, unboxing 很耗系統效能與記憶體。</p></td></tr></tbody></table><h2>類別與結構</h2><table class="table table-hover"><thead><tr><th>關鍵字</th><th>說明</th></tr></thead><tbody><tr><td>類別 class</td><td>可被繼承。</td></tr><tr><td>結構 struct</td><td>不可被繼承。也因為如此，適合宣告運算子多載，因為有些運算子最後會吐出類別，而這個類別有可能是父類別，而不是使用者現在正在操作的子類別。</td></tr><tr><td>運算子多載</td><td>前面要宣告static。</td></tr></tbody></table><h6>OOP ObjectOrientedProgramming</h6></main><footer></footer><script src=/.file/site.js></script><script src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-7039045520564660"></script></body></html>